#!/usr/bin/env perl
use warnings;
use strict;
use utf8;
use JSON;
use Pod::Usage;
use Getopt::Long;
use HTTP::Request;
use HTTP::Response;
use LWP::UserAgent;
use Encode qw(decode);
use File::Slurp qw/slurp/;
use Term::ANSIColor qw/:constants/;
use I18N::Langinfo qw(langinfo CODESET);
use constant {
	DAUM_ENDIC_URL => "http://apis.daum.net/dic/endic?apikey=%s&kind=WORD&output=json&q=%s", 
	GOOGLE_TRANSLATE_API_URL => 'http://ajax.googleapis.com/ajax/services/language/translate?v=1.0&q=%s&langpair=%s', 
};

our $VERSION = '1.0001';
$VERSION = eval $VERSION;

binmode STDOUT, ":utf8";

my %options;
GetOptions(\%options, "--file=s", "--lang=s", "--help");
my $codeset = langinfo(CODESET);
@ARGV = map { decode $codeset, $_ } @ARGV;
run(\%options, @ARGV);

sub run {
    my($opts, @words) = @_;
	pod2usage(0) if $opts->{help};
	my $lang = $opts->{lang} || 'en|ko';
	unshift @words, scalar slurp($opts->{file}) if $opts->{file};
	push(@words, join '', <STDIN>) if scalar @words eq 0;

	{
		use Data::Dumper qw/Dumper/;
		local $Term::ANSIColor::AUTORESET = 1;
		for my $word (@words) {
			my $trim_word = $word;
			$trim_word =~ s/\s+//g;
			next unless length $trim_word;

			print BOLD BLUE $word, "\n";

			my $translated;
			$translated = get_google($word, $lang);
			while (my ($key, $value) = each %{ $translated }) {
				print "$key\n";
				print "\t$value\n";
			}

			$translated = get_daum($word);
			while (my ($key, $value) = each %{ $translated }) {
				print "$key\n";
				print "\t$value\n";
				print "끗!\n";
			}
		}
	}
}

sub get_google {
	my ($origin, $lang) = @_;
	my $url = url_encode(sprintf(GOOGLE_TRANSLATE_API_URL, $origin, $lang));
	my $translated = get_translated($url, $lang);
	return { $origin => $translated->{responseData}->{translatedText} };
}

sub get_daum {
    my ($origin, $lang) = @_;
	$ENV{DAUM_ENDIC_KEY} = 'DAUM_DIC_DEMO_APIKEY' unless $ENV{DAUM_ENDIC_KEY};
	my $url = sprintf(DAUM_ENDIC_URL, $ENV{DAUM_ENDIC_KEY}, $origin);
	my $translated = get_translated($url, $lang);
	my %translated;
	for my $translated_item (@{ $translated->{channel}->{item} }) {
		$translated{ $translated_item->{title} } = $translated_item->{description};
	}

	return \%translated;
}

sub get_translated {
	my ($url, $lang) = @_;
	my $request = HTTP::Request->new(GET => $url);
	my $ua = LWP::UserAgent->new;
	my $response = $ua->request($request);
	print STDERR $response->status_line, "\n" unless $response->is_success;
	return from_json($response->content, utf8 => 1);
}

sub url_encode {
	my $url = shift;
	$url =~ s/([^A-Za-z0-9:\/?&]=)/sprintf("%%%02X", ord($1))/seg;
	return $url;
}

sub url_decode {
	my $url = shift;
	$url =~ s/\%([A-Fa-f0-9]{2})/pack('C', hex($1))/seg;
	return $url;
}

__END__

=head1 NAME

eng2kor - English to Korean
Dictionary Service

=head1 POWERED BY Google & Daum

=head1 SYNOPSIS

	eng2kor --help

	eng2kor english														# eng2kor
	eng2kor 한국말                                                 	    # kor2eng
	eng2kor some thing "something"                                      # multiple
	eng2kor "this is sentence"                                          # sentence
	echo "word" | eng2kor                                               # pipe input
	eng2kor --file=eng.txt                                              # file
	export DAUM_ENDIC_KEY=e4208a9e48744c40f2b7459162062313ed9878f6      # note: just sample, invalid key

=head1 INSTALL

	perl Makefile.PL
	make
	make test
	make install

=head1 SEE ALSO

* L<http://dna.daum.net/griffin/do/DevDocs/read?bbsId=DevDocs&articleId=11>

=cut

1; # End of eng2kor
